#  lab1基础知识归纳（BOOSTLOADER）

##  一. 启动过程

###  1. BIOS

电脑在通电的时候会首先CPU默认去执行内存上的ROM的指令，此时处于实模式的状况之下。此时可用的空间只有1M.

BIOS固件，当中存储有系统启动所需要的信息。

BIOS 用中断调用的模式提供了I/O的功能。

其结构存在：

![1570783438726](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1570783438726.png)



加电之后，该命令会去读取磁盘上的系统代码（包括程序加载，操作系统）

加载程序是为满足多样的操作系统的可兼容性。

### 2.系统启动的流程

####  		流程描述：BIOS固件通电--磁盘扇索引-----区的索引----加载程序

###  3. 中断，异常和系统调用的比较

####   （1）背景

#####  			A.内核的进入和退出  

####     (2)  中断

####  （3）异常

####  （4）系统调用

A. ucore当中read()是用来读文件的，关注这个对应的参数和返回值便于使用这个函数。

read（fd,buffer,length）

##  二. UCORE实际代码编写

###  1. 系统函数调用的具体运用



###  2. 



###  3.











##  三.具体lab1实验

###  1. x86的启动顺序

x86启动寄存器的初始变化：

一开始所有的寄存器都有初始值。

段地址CS ：F000H

指令寄存器EIP：0000FFF0H

ucore地址计算，指令地址计算是按照实模式的地址寻址方式来计算的，也是为了兼容16位的机器，其地址计算就按照：BASE +EIP =  FFFF0000H +0000FFF0H = <font color ="#660000">FFFFFFF0H</font>

这个是BIOS的在内存当中只读取部分ROM的地址。（实模式下，BUS 只有20位，所以只有1M得寻址空间）

从这个地址会取得第一个指令（长跳转指令）

段寄存器 段选择子 偏移量

BIOS主要加载简单的硬件代码，BIOS加载存储设备上的第一个扇区，把512字节到内存当中的0X7c000。。。。。，然后开始执行这段代码，而这段代码就是bootloader

BOOTLOADER的作用：

* 实模式--->保护模式（16--》32、、、1M-->4G）//段机制正常工作

* 从硬盘上读取UCORE代码（kernel  in ELE格式），并放到内存当中执行。（涉及多个扇区）

* 转交控制权，SC EIP的值变化到ucore操作系统的的入口点，这样接下来执行的指令就是ucore里的指令了。

段机制（segment ）

segment register-->就像是指针一样指向到对应的代码区域（映射地址的作用）

段落大小就是4G空间（后续的页机制有重复）

segment selector =index的作用，找到段描述符，有起始地址（BASE）和具体的长度，加上EIP的值就是线性地址。

全局描述符表---GDT是由bootloader建立的，也就是他建立了段机制。

16位的全局描述表的单位内容段描述符当中高13位放的是index + 特权 +

进入保护模式CRO控制寄存器，把第0个bit 编程 1就成为保护模式了



加载ELE格式的ucore代码

解析ELE格式的信息（翻译）：存在

找到ELE的header代码部分，找到虚地址放在那里，也就是识别出对应的重要信息，然后加载对应的代码段，实际上是读取了所有的扇区的读取工作，然后加载了对应的代码。

